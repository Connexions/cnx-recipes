@import "./utils";

@mixin number_numberChapters($chapterTitleContent) {
  div[data-type="chapter"] {

    //use the title mixin for this? and that way content() can be wrapped
    > [data-type="document-title"] {
      tag-name-set: "h1";
      @include utils_title($chapterTitleContent);
      &::inside {
        tag-name-set: "span";
        class-add: "os-text";
      }
    }
  }
}

@mixin number_numberAppendices($appendixTitleContent) {
  div.appendix {
    //use the title mixin for this? and that way content() can be wrapped
    > [data-type="document-title"] {
      tag-name-set: "h1";
      @include utils_title($appendixTitleContent, bAppendixLabel);
    }
  }
}

@mixin number_numberSections($sectionTitleContent) {
  div[data-type="chapter"] > div[data-type="page"] {
    &:not(.introduction) {
      //use the title mixin for this? and that way content() can be wrapped
      > [data-type="document-title"] {
        tag-name-set: "h2";
        @include utils_title($sectionTitleContent, bSectionLabel);
      }
    }
    &.introduction {
      > [data-type="document-title"] {
        tag-name-set: "h2";
      }
    }
  }
}

/// This has to run before number_numberEOCExercises because its selector is more general
/// @group number
@mixin number_numberContentExercises($exerciseTitleContent, $solutionTitleContent, $exerciseTitleContentAp, $solutionTitleContentAp) {
  [data-type="chapter"] [data-type="page"] [data-type="exercise"]:not(.unnumbered) {
    @if $exerciseTitleContent {
      [data-type="problem"] {
        @include utils_title($exerciseTitleContent);
      }
    }
    @if $solutionTitleContent {
      [data-type="solution"] {
        @include utils_title($solutionTitleContent);
      }
    }
  }
  .appendix [data-type="exercise"]:not(.unnumbered) {
    @if $exerciseTitleContentAp {
      [data-type="problem"] {
        @include utils_title($exerciseTitleContentAp);
      }
    }
    @if $solutionTitleContentAp {
      [data-type="solution"] {
        @include utils_title($solutionTitleContentAp);
      }
    }
  }
}

//EOC composite pages must be created before this runs
@mixin number_numberEOCExercises($exerciseTitleContent, $solutionTitleContent) {
  .os-eoc [data-type="exercise"] {
    [data-type="problem"] {
      @include utils_title($exerciseTitleContent);
    }
    [data-type="solution"] {
      @include utils_title($exerciseTitleContent);
    }
  }
}

@mixin number_numberExamples($exampleTitleContent, $solutionTitleContent) {
  [data-type="example"] {
    @include utils_title($exampleTitleContent, bExampleLabel);
    > [data-type="title"] {
      //BAD: there should not be titling content creation outside the book level. This should get moved
      $exampleTitle: (
        os-text: content()
      );
      @include utils_title($exampleTitle, bExampleLabel);
      move-to: trash;
    }
    &::after {
      tag-name-set: "div";
      content: pending(bExampleLabel);
      class-add: "os-title";
      move-to: bExampleHeader;
    }
    &:deferred {
      content: pending(bExampleHeader) content();
    }
    [data-type="solution"] {
      @include utils_title($solutionTitleContent, null, div, "solution-title");
    }
  }
}

@mixin number_numberNote($type, $noteContent, $hasSolutions, $solutionTitleContent) {
  [data-type="note"].#{$type} {
    @include utils_title($noteContent, bNoteLabel-#{$type});
    > [data-type="title"] {
      //TODO: May want to have the option to preserve titles similarly to examples in the future.
      move-to: trash;
    }
    @if $hasSolutions {
      [data-type="solution"] {
        @include utils_title($solutionTitleContent)
      }
    }
    &::after {
      tag-name-set: "div";
      content: pending(bNoteLabel-#{$type});
      class-add: "os-title";
      move-to: bNoteHeader;
    }
    &:deferred {
      content: pending(bNoteHeader) content();
    }
    //TODO: Maybe want to have the option to handle solutions similarly to examples in the future
  }
}

@mixin number_setCaptions($setFigTableCaptions, $labeling, $labelingAp) {
  $captionType:         map-get($setFigTableCaptions, captionType);
  $defaultContainer:    map-get($setFigTableCaptions, defaultContainer);
  $hasCaption:          map-get($setFigTableCaptions, hasCaption);
  $hasTitle:            map-get($setFigTableCaptions, hasTitle);
  $exceptionClassNames: map-get($setFigTableCaptions, exceptionClassNames);

  // $noTitleContent: (); // For the exceptions, this is the "titleContent" that will be used

  @include validate_enum($captionType, $CAPTION__PREFIX__);
  @include validate_typeOptional($exceptionClassNames, list);
  // These selectors are of the form:
  // `table:not(.unnumbered):not(.custom1):not(.custom2)` (everything that is not an exception)
  // `table.unnumbered, table.custom1, table.custom2`     (everything that is an exception)
  $elementName: "INVALID_ELEMENT_NAME";
  @if $captionType == $CAPTION_TABLE {
    $elementName: "table";
  } @else if $captionType == $CAPTION_FIGURE {
    $elementName: "figure";
  } @else {
    @error "BUG: Invalid captionType '#{$captionType}'";
  }
  $notAnExceptionSelector: "#{elementName}";
  $exceptionsSelector: "";
  @if $exceptionClassNames {
    @each $item in $exceptionClassNames {
      @include validate_type($item, string);
      $notAnExceptionSelector: unquote("#{$notAnExceptionSelector}:not(.#{$item})");
      // Only add a comma if there is already an $exceptionsSelector
      @if $exceptionsSelector == "" {
        $exceptionsSelector: unquote("#{$elementName}.#{$item}");
      } @else {
        $exceptionsSelector: unquote("#{$exceptionsSelector}, #{$elementName}.#{$item}");
      }

    }
  }

  [data-type="chapter"] {
    :not(#{$elementName}) > #{$elementName}:not(.unnumbered) {
      @include setCaptionsHelper($labeling, $captionType, $defaultContainer, $hasCaption, $hasTitle);
    }
    @include trashUnnumberedCaption($elementName, $defaultContainer);
  }
  .appendix {
    :not(#{$elementName}) > #{$elementName}:not(.unnumbered),
    > #{$elementName}:not(.unnumbered) {
      @include setCaptionsHelper($labelingAp, $captionType, $defaultContainer, $hasCaption, $hasTitle);
    }
    @include trashUnnumberedCaption($elementName, $defaultContainer);
  }

}


@mixin trashEmptyCaption ($type, $defaultContainer) {
  > #{$type} {
    #{$defaultContainer}:empty {
      move-to: trash;
    }
  }
}

/// TODO: Determine why this is the case
/// Unnumbered captions are currently trashed (even if they contain content) because
/// of some contract that the XML teams had which stated something along the lines
/// of "If a table/figure is unnumbered then openstax will discard the caption"
@mixin trashUnnumberedCaption ($elementName, $defaultContainer) {
  > #{$elementName}.unnumbered {
    #{$defaultContainer} {
      x-display: none;
    }
  }
}

@mixin setCaptionsHelper($labeling, $captionType, $defaultContainer, $hasCaption, $hasTitle) {

  @if ($hasCaption) {
    #{$defaultContainer} {
      tag-name-set: "span";
      class-add: "os-caption";
      // move-to: bCaptionContent;
    }
  }

  // pending(bCaptionTitle)
  $_captionTitleToMove: 'HACK_FOR_VARIABLE_SCOPING';
  @if ($captionType == $CAPTION_TABLE) {
    $_captionTitleToMove: parent-context(move-here('#{$defaultContainer} [data-type="title"]'));
    #{$defaultContainer} [data-type="title"] {
      tag-name-set: "span";
      class-add: "os-title";
    }
  } @else if ($captionType == $CAPTION_FIGURE) {
    $_captionTitleToMove: parent-context(move-here('[data-type="title"]'));
    [data-type="title"] {
      tag-name-set: "span";
      class-add: "os-title";
    }
  } @else {
    @error "BUG: Invalid captionType '#{$captionType}'";
  }

  #{$defaultContainer}::outside {
    tag-name-set: "div";
    class-add: "os-caption-container";

    // pending(bCaption)
    // adds the os-title-label, os-number, and os-divider
    @include utils_title($labeling, bCaption, $CONTEXT_PARENT);

    // TODO: Maybe just use `:has([data-type="title"])`
    @if ($hasTitle) {
      // create divider span for title
      &::before(2) {
        tag-name-set: "span";
        class-add: 'os-divider';
        content: ' ';
        move-to: bCaptionDivider;
      }
      &::before(1) {
        content: $_captionTitleToMove;
      }
    }

    // TODO: ERROR when setting content: inside an ::outside element. This means that when move-to runs it might move the inner node but not this one.
    // content: $_captionTitleToMove;

    // content:
    // pending(bCaption)
    // pending(bCaptionTitle)
    // pending(bCaptionDivider)
    // pending(bCaptionContent);
  }
  &::outside {
    tag-name-set: "div";
    @if $captionType == $CAPTION_TABLE {
      class-add: os-table;
    } @else if $captionType == $CAPTION_FIGURE {
      class-add: os-figure;
    } @else {
      @error "BUG: Invalid captionType '#{$captionType}'";
    }
  }
}

@mixin number_equations ($numberedEquation, $numberAfterEq) {
  [data-type="chapter"], .appendix {
    [data-type="equation"]:not(.unnumbered) {
      @if $numberAfterEq {
        @include utils_title($numberedEquation, equationNum);
        &::after {
          class-add: os-equation-number;
          tag-name-set: "div";
          content: pending(equationNum)
        }
      } @else {
        @include utils_title($numberedEquation);
      }
    }
  }
}

@mixin number_footnotes($footnoteCounter, $footnoteLinkCounter) {
  // Footnotes option 1
  li[data-type="footnote-ref"] > a[data-type="footnote-ref-link"] {
    content: count_footnotes();
  }
  sup[data-type="footnote-number"] > a[data-type="footnote-link"] {
    content: count_footnoteLinks();
  }
  // Footnotes option 2
  li > a[data-type="footnote-ref"] {
    content: count_footnotes();
  }
  a[data-type="footnote-number"] > sup {
    content: count_footnoteLinks();
  }
}

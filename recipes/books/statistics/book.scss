@import '../../mixins/_all';
@import './_config';
// @import '../_generator';

// This is the ROOT of the output CSS file that is generated.

@import '../../mixins/_all';

// Import the book-specific config file
@import './_config';


// HACK
// SASS has a bug where it allows you to write `:not(.foo)` but not the following:
// `:not(:has(foo))` , `:not(a, b)`
//
// So to get around that, there is code below that looks like this: `&:not(:not(SASS_HACK):has(`



@mixin sectionNumber() {
  content: ancestor-context('body', count-of-type('[data-type="chapter"]')) '.' ancestor-context('[data-type="chapter"]', count-of-type('[data-type="page"]:not(:has(cnx-pi[data-type="cnx.flag.introduction"]))')) ' ';
}

@mixin sectionTitleAndLink() {
  // x-assert: x-is('[data-type="page"]');

  &:has(> [data-type="metadata"] > [data-type="document-title"]) {
    &:not(:not(SASS_HACK):has(cnx-pi[data-type="cnx.flag.introduction"])) {
      /* Number the non-Introduction Pages */
      &::before {
        tag-name-set: "h3";
        class-add: "section-title";
        content: descendant-context('> [data-type="metadata"] > [data-type="document-title"]', text-contents());

        &::before {
          /* Section Numbering */
          tag-name-set: "a";
          attrs-add: "href" "#" attr(id);
          @include sectionNumber();
        }
      }
    }
    &:has(cnx-pi[data-type="cnx.flag.introduction"]) {
      /* Add a title but do not number the Introduction modules */
      &::before {
        tag-name-set: "h3";
        class-add: "section-title";
        content: descendant-context('> [data-type="metadata"] > [data-type="document-title"]', text-contents());
      }
    }

  }
  // &:not(:not(SASS_HACK):has(> [data-type="metadata"] > [data-type="document-title"])) {
  //   &::before {
  //     class-add: "section-title";
  //     x-log: "ERROR: mangled HTML";
  //   }
  // }
}

// /* Just for testing memory/processing limits */
// * { tag-name-set: none; }

$selectorsToAddForCountingAccumulator: ();
$exerciseSolutionSelectorAccumulator: ();

@for $index from 1 through length($Config_ChapterCompositePages) {
  $item: nth($Config_ChapterCompositePages, $index);

  $name: map-get($item, name);
  $className: map-get($item, className);
  $isGlossary: map-get($item, isGlossary);
  // $sortBy: map-get($item, sortBy);
  $sectionSeparated: map-get($item, sectionSeparated);
  // $hasSolutions: map-get($item, hasSolutions);
  // $compoundComposite: map-get($item, compoundComposite);
  // $moveSolutionsTo: map-get($item, moveSolutionsTo);

  $selector: "section.#{$className}";
  $selectorChildren: '#{$selector} > *:not([data-type="title"])'; // For moving, we want to move all the children in the collated section
  $exerciseSelector: '#{$selector} [data-type="exercise"]';
  $selectorsToAddForCounting: $selectorsToAddForCountingAccumulator;
  $selectorsToAddForCountingAccumulator: append($selectorsToAddForCountingAccumulator, $exerciseSelector, comma);

  // Remember all exercise types that have solutions that need to be moved to the end of the book
  $exerciseSolutionSelector: '#{$exerciseSelector} [data-type="solution"]';
  $exerciseSolutionSelectorAccumulator: append($exerciseSolutionSelectorAccumulator, $exerciseSolutionSelector, comma);


  /* End-of-chapter page for #{$selector} */
  body > [data-type="chapter"] {

    /* Number the exercises for each section */
    #{$selector} {
      /* discard the section since the contents (not this section) is collated to the end-of-chapter */
      x-display: none;

      // Number the Solutions and exercises the same way
      // TODO: sass does not show sourcemap info when selectors have a comma GRRRRR, hence copy-pasta
      [data-type="exercise"]::before,
      [data-type="exercise"] [data-type="solution"]::before {
        @if length($selectorsToAddForCounting) >= 1 {
          content: ancestor-context('[data-type="chapter"]', add(count-all-of-type("#{$selectorsToAddForCounting}"), count-of-type($exerciseSelector)));
        } @else {
          content: ancestor-context('[data-type="chapter"]', count-of-type($exerciseSelector));
        }
      }

      /* Make links from exercise to solution and from solution to exercise */
      [data-type="exercise"]:not(:not(SASS_HACK):has([data-type="solution"]))::before {
        /* Make the number for an exercise without solution bold */
        tag-name-set: "strong";
      }
      [data-type="exercise"]:has([data-type="solution"])::before {
        tag-name-set: "a";
        attrs-add: "href" "#" descendant-context('[data-type="solution"]', attr(id));
      }
      [data-type="exercise"] [data-type="solution"]::before {
        tag-name-set: "a";
        attrs-add: "href" "#" parent-context(attr(id));
      }

    }

    @if $isGlossary {
      &:has([data-type="glossary"] > dl > dt) {
        /* Only generate a glossary if there are terms in this chapter */
        /* Discard the old section-level glossary element */
        [data-type="glossary"] {
          x-display: none;
        }
        &::after(#{$index}) {
          &::before {
            tag-name-set: "h2";
            content: $name;
          }

          // TODO: Make this a <dl> and make it sorted
          &::after {
            tag-name-set: "ul";

            &::for-each-descendant(1, '[data-type="glossary"] > dl > dt') {
              tag-name-set: "li";

              // Add the term
              &::after(1) {
                tag-name-set: "strong";
                class-add: "term";
                // TODO: use contents() instead of text-contents()
                content: text-contents();
              }
              &::after(2) {
                tag-name-set: "span";
                class-add: "separator";
                content: ": ";
              }
              &::after(3) {
                tag-name-set: "div";
                class-add: "definition";
                // TODO: use contents() instead of text-contents()
                content: next-sibling-context('dd:first', text-contents());
              }
            }
          }
        }


      }

    } @else {
      // Some end-of-chapter items do not have any elements to move.
      // In that case, do not bother adding the title.
      &:has(#{$selector}) { // Added `section` to speed up the :has lookup

        &::after(#{$index}) {
          /* Title */
          &::before {
            tag-name-set: "h2";
            content: $name;
          }

          // add a section separator
          @if $sectionSeparated {
            /* Is sectionSeparated */
            &::for-each-descendant(1, '> [data-type="page"]') {
              &:has(#{$selector}) {
                @include sectionTitleAndLink();
                class-add: "eoc-section";

                content: move-here($selectorChildren);
              }
            }

          } @else {
            /* Not sectionSeparated */
            content: ancestor-context('[data-type="chapter"]', move-here($selectorChildren));
          }
          // x-log: "INFO: Generating end-of-chapter page for .#{$className} for chapter " ancestor-context('body', count-of-type('[data-type="chapter"]'));
        }
      }
      // // Example of Logging when a end-of-chapter page was not generated
      // &:not(:not(SASS_HACK):has(.#{$className})) {
      //   x-log: "WARNING: Skipping end-of-chapter page for .#{$className} for chapter " ancestor-context('body', count-of-type('[data-type="chapter"]')) " because no items were found";
      // }
    }
  }
}


body > [data-type="chapter"] {

  /* Numbers on chapters and sections */
  > [data-type="document-title"] {
    &::before(2) {
      tag-name-set: "span";
      class-add: "os-number";
      content: ancestor-context('body', count-of-type('[data-type="chapter"]')) '. ';
    }
    &::before(1) {
      tag-name-set: "span";
      class-add: "os-divider";
    }
    &::inside {
      tag-name-set: "span";
      class-add: "os-text";
    }
  }

  /* Discard Page metadata but keep the title (and add its number) */
  [data-type="page"] {
    > [data-type="metadata"] {
      /* TODO: Move this to an attribution section at the end of the book */
      x-display: none;
    }
    > [data-type="document-title"] {
      tag-name-set: "h2";
    }
    // &:not(:not(SASS_HACK):has(cnx-pi[data-type="cnx.flag.introduction"])) {
    //   &:has(> [data-type="metadata"] > [data-type="document-title"]) {
    //     &::before {
    //       tag-name-set: "h2";
    //       attrs-add: "data-type" "document-title", "id" descendant-contextattr(id);
    //       content: descendant-context('> [data-type="metadata"] > [data-type="document-title"]', text-contents());
    //
    //       &::before {
    //         tag-name-set: "span";
    //         @include sectionNumber();
    //       }
    //     }
    //   }
    // }
    // &:has(cnx-pi[data-type="cnx.flag.introduction"]) {
    //   &:has(> [data-type="metadata"] > [data-type="document-title"]) {
    //     &::before {
    //       /* Label the Introduction but do not add a number */
    //       tag-name-set: "h2";
    //       content: descendant-context('> [data-type="metadata"] > [data-type="document-title"]', text-contents());
    //     }
    //   }
    // }

    /* The following are hacks for the styleguide since they are missing metadata */
    &:not(:not(SASS_HACK):has(> [data-type="metadata"] > [data-type="document-title"])) {
      // x-log: "Probably generating a styleguide so there is no metadata element";
      &:has(> [data-type="document-title"]) {
        &::before {
          tag-name-set: "h2";
          content: descendant-context('> [data-type="document-title"]', text-contents());
          &::before {
            tag-name-set: "span";
            @include sectionNumber();
          }
        }
      }
      &:not(:not(SASS_HACK):has(> [data-type="document-title"])) {
        &::before {
          tag-name-set: "h2";
          content: "STYLEGUIDE_TITLE_PLACEHOLDER";
          &::before {
            tag-name-set: "span";
            @include sectionNumber();
          }
        }
      }
    }
  }
}


body {

  // Delete the metadata
  // TODO: Why are these inconsistent
  > [data-type="metadata"] {
     > [data-type="description"] {
      x-display: none;
    }
  }
  > [data-type="page"].preface > [data-type="metadata"] {
    x-display: none;
  }


  &:has(> [data-type="chapter"]:has(#{$exerciseSolutionSelectorAccumulator})) {
    &::after(1) {
      &::before {
        tag-name-set: "h1";
        content: "Answer Key";
      }
      &::for-each-descendant(1, '[data-type="chapter"]'):has(#{$exerciseSolutionSelectorAccumulator}) {
        /* Chapter title */
        &:has([data-type="page"]:has(cnx-pi[data-type="cnx.flag.introduction"])) { /* This guard is just for the styleguide */
          &::before {
            &::before {
              content: $CHAPTER_COUNT " ";
              // tag-name-set: "span";
              // Link to the introduction module (TODO: when subcollections have id's then this will not be necessary)
              // tag-name-set: "a";
              // attrs-add: "href" "#" descendant-context('[data-type="page"]:has(cnx-pi[data-type="cnx.flag.introduction"])', attr(id));
            }
            tag-name-set: "h2";
            content: descendant-context('> [data-type="document-title"]', text-contents());
          }
          /* Chapter Answers */
          content: move-here('#{$exerciseSolutionSelectorAccumulator}');
        }
      }
    }
  }

  // Start of any Page
  // TODO: don't make it specific to a chapter
  [data-type="chapter"] > [data-type="page"] {

    // Format the Page Title. Introductions do not have a number
    > h2 { x-display: none; }
    &.introduction {
      > [data-type="document-title"] {
        tag-name-set: "h2";
        &::inside {
          tag-name-set: "span";
          class-add: "os-text";
        }
      }
    }
    &:not(.introduction) {
      > [data-type="document-title"] {
        tag-name-set: "h2";
        &::before(2) {
          tag-name-set: "span";
          class-add: "os-number";
          content: parent-context(collect-all($SECTION_COUNT));
        }
        &::before(1) {
          tag-name-set: "span";
          class-add: "os-divider";
          content: " ";
        }
        &::inside {
          tag-name-set: "span";
          class-add: "os-text";
        }
      }
    }

    // Random things inside the page
    figure:has(figcaption) {
      &::outside {
        tag-name-set: "div";
        class-add: "os-figure";
        // move the figcaption into here. The caption is transformed in number_setCaptions
        // TODO: make this extra element disappear
        &::after {
          content: move-here('> figcaption');
        }
      }
    }
  }

  @include number_setCaptions($Config_SetFigureCaption, $Config_PartType_Figure_CaptionContent, $Config_PartType_Figure_CaptionContentAp);
}









// Copy/pasta from _generator.scss



@mixin misc_webview_styling() {
  // Adapted from https://github.com/Connexions/webview/blob/master/src/scripts/modules/media/body/content-common.less#L341
  //   // Block-ish lists
  //   ul:not([data-display='inline'])          { @include list_style(block, bulleted); }
  //   ol:not([data-display='inline'])          { @include list_style(block, enumerated); }
  //   ul[data-labeled-item]                    { @include list_style(block, labeled-item); }
  //
  //   // Inline lists (with `data-display='inline'`)
  //   ul[data-display='inline']                { @include list_style(inline, bulleted); }
  //   ol[data-display='inline']                { @include list_style(inline, enumerated); }
  //   ul[data-display='inline'][data-labeled-item] { @include list_style(inline, labeled-item); }
  //
  //   // Lists inside a paragraph
  //   [data-type='list']:not([data-list-type]):not([data-labeled-item])
  //                                                     { @include list_style-emulated(inline, bulleted); }
  //   [data-type='list'][data-list-type='bulleted']     { @include list_style-emulated(inline, bulleted); }
  //   [data-type='list'][data-list-type='enumerated']   { @include list_style-emulated(inline, enumerated); }
  //   [data-type='list'][data-list-type='labeled-item'] { @include list_style-emulated(inline, labeled-item); }
  //   div[data-type='list'][data-list-type]             { padding-left: 2.5rem; margin-bottom: 1rem; }

  [data-type='list']:not([data-list-type]),
  [data-type='list'][data-list-type='bulleted'],
  [data-type='list'][data-list-type='enumerated'] {
    // Throw an erros just to make sure these cases do not occur
    sort-by: 'invalid-namespace-just-to-throw-an-error|element-HACK';
  }

  [data-type='list'][data-list-type='labeled-item'],
  [data-type='list'][data-list-type='bulleted'] {

    &:not([data-item-sep]) > span[data-type="item"]:not(:last-child)::after {
      // content: @default-inline-list-item-sep;
      tag-name-set: "span";
      attr-class: "-os-inline-list-separator";
      content: "; ";
    }
    &[data-item-sep] {
      > [data-type="item"]:not(:last-child)::after {
        // content: @default-inline-list-item-sep;
        // .x-not-implemented('data-item-sep=CUSTOM');
        tag-name-set: "span";
        class-add: "-os-inline-list-separator";
        content: parent-context(attr(data-item-sep));
      }
    }
  }
}
@include misc_webview_styling();


@include modify_titlePreface();
@include modify_spanWrapTitles();
@if $Config_Coverage_MayHaveSimlinks == true {
  @include modify_simLinkTarget();
}
@include modify_wrapExercises(); // no dependencies
@include modify_wrapLists(); // no dependencies

@if $Config_Coverage_MayHaveIframes == true {
  @include modify_wrapIframesWithAlternatives(); // no dependencies
}

@include modify_trash("cnx-pi");

// Only mark up solutions if they will not be discarded (optimization)
@if map-get($Config_PartType_Solution, moveTo) == $AREA_TRASH {
} @else {
  @include utils_hasSolution(REMOVEME);
}

@if $Config_HACK_modifyAnyContainerTitleSelector {
  @include modify_anyContainerTitle($Config_HACK_modifyAnyContainerTitleSelector, null);
}
@include modify_GenericNote();

@each $unnumberedEquation in $Config_UnnumberedEquations {
  $contextSelector: map-get($unnumberedEquation, contextSelector);
  $childSelector: map-get($unnumberedEquation, childSelector);
  @include validate_type($contextSelector, string);
  @include validate_typeOptional($childSelector, string);
  @include modify_addUnnumbered($contextSelector, $childSelector);
}





@if $Config_Coverage_MayHaveMissingExercises {
  @include modify_trash('[data-type="exercise"].missing-exercise');
}

// Any notes that need to trash the solution
@each $note in $Config_Notes {
  $className: map-get($note, className);
  $moveSolutionTo: map-get($note, moveSolutionTo);
  @include validate_type($className, string);
  @include validate_enumOptional($moveSolutionTo, $AREA__PREFIX__);

  @if $moveSolutionTo == $AREA_TRASH {
    @include modify_trash('.#{$className} [data-type="solution"]');
    @include utils_clearTrash();
  } @else {
    // TODO Skip reconstructing a new object for modify_note
    $labelText: map-get($note, labelText);
    $titleContent: map-get($note, titleContent);
    $replaceHeader: map-get($note, replaceHeader);
    $useHeader: map-get($note, useHeader);
    @include validate_typeOptional($useHeader, bool);
    @include validate_typeOptional($labelText, string);
    @include validate_typeOptional($titleContent, map);

    // Check that there is not both a label AND a titleContent
    @if $labelText and $titleContent {
      @error "BUG: Specified both a label and a titleContent";
    } @else if $useHeader {
      @include modify_note((className: $className, useHeader: $useHeader));
    } @else if $labelText {
      @include modify_note((className: $className, labelText: $labelText, replaceHeader: $replaceHeader));
    } @else if $titleContent {
      @include modify_note((className: $className, titleContent: $titleContent, replaceHeader: $replaceHeader));
    }
  }
}


/* Discard all processing instructions */
/* body > [data-type="chapter"] > */ [data-type="page"] {
  cnx-pi {
    x-display: none;
  }
}

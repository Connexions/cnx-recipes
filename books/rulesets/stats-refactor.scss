//Import order doesn't affect output
@import 'common-refactor/compose';
@import 'common-refactor/count';
@import 'common-refactor/link';
@import 'common-refactor/modify';
@import 'common-refactor/number';
@import 'common-refactor/reference';
@import 'common-refactor/utils';


//TODO: Improve performance by using more specific selectors in libraries when possible
//TODO: Separate Metadata and document-titles from composite creation mixins
//TODO: target-labels
//TODO: Numbering Figs, Tabs, book specific items (labs, try its)
//TODO: TOC
//TODO: Missing IDs, modify raw objects (wrapping, ids, target: _blank)
//TODO: URI
//TODO: Separate object files
//TODO: Misc books specific things

//Different language mock-up
$lang: "en";
$chapter_en: "Chapter";
$appendix_en: "Appendix";
$chapter_de: "Kapitel";
$appendix_de: "Anhang";

//Base object to be inherited
$compositePage_obj: (
  name: null,
  source: null,
  sectionSeparated: false,
  compoundComposite: false
);

//Inherit compositePage object
@function compositePage($params) {
  @return map-merge($compositePage_obj, $params);
}

$compositePageChapter_obj: compositePage((
  hasSolutions: false,
  isGlossary: false,
  sortBy: null,
));

@function chapterComposite($params) {
  @return map-merge($compositePageChapter_obj, $params);
}

$compositePageBook_obj: compositePage((
  chapterSeparated: false,
  chapterPages: false,
  isIndex: false,
));

@function bookComposite($params) {
  @return map-merge($compositePageBook_obj, $params);
}

// object keys can be overriden per book:
// $compositePage_obj: map-merge($compositePage_obj,
//   (nameClass: "text")
// );

$pageKeyTerms: chapterComposite((
  name: "Key Terms",
  source: "glossary",
  isGlossary: true,
  sortBy: "dl > dt"
));

$pageChapterReview: chapterComposite((
  name: "Chapter Review",
  source: "summary",
  sectionSeparated: true
));

$pageFormulaReview: chapterComposite((
  name: "Formula Review",
  source: "formula-review",
  sectionSeparated: true
));

$pagePractice: chapterComposite((
  name: "Practice",
  source: "practice",
  sectionSeparated: true,
  hasSolutions: true
));

$pageBITExercises: chapterComposite((
  name: "Bringing It Together: Exercises",
  source: "bring-together-exercises",
  hasSolutions: true
));

$pageHomework: chapterComposite((
  name: "Homework",
  source: "free-response",
  sectionSeparated: true,
  hasSolutions: true
));

$pageBITHomework: chapterComposite((
  name: "Bringing It Together: Homework",
  source: "bring-together-homework",
  hasSolutions: true
));

$pageReferences: chapterComposite((
  name: "References",
  source: "references",
  sectionSeparated: true
));

$pageSolutions: chapterComposite((
  name: "Solutions",
  source: "solutions",
  compoundComposite: true
));

$chapterCompositePages: (
  $pageKeyTerms,
  $pageChapterReview,
  $pageFormulaReview,
  $pagePractice,
  $pageBITExercises,
  $pageHomework,
  $pageBITHomework,
  $pageReferences,
  $pageSolutions
);

$pageIndex: bookComposite((
  name: "Index",
  source: "index",
  isIndex: true
));

$bookCompositePages: (
  //This doesn't get parsed as a list without a comma at the end, the composite builder must account for this
  $pageIndex,
);

//make content maps
//unfortunately a base obj cannot be created for all Content because it would make the order of the keys static
//when they need to be able to be in any order because of possible changes in titling order between books
$chapterTitleContent: (
  label: "Chapter",
  number: counter(chapter),
  divider: "|"
);

$appendixTitleContent: (
  label: "Appendix",
  number: counter(appendix, upper-alpha),
  divider: ":"
);

$sectionTitleContent: (
  number: counter(chapter)"."counter(section),
  divider: "|"
);

$exerciseTitleContent: (
  number: counter(exercise)
);

$exampleTitleContent: (
  label: "Example",
  number: counter(chapter)"."counter(example)
);

$exampleSolutionTitleContent: (
  label: "Solution",
  number: counter(chapter)"."counter(example)
);

//New pass system
:pass(0) {
  //Possibly not needed later
  @include titlePreface();
  //Come up with mixins for common numbering schemes as per Phil's suggestion
  @include countChapters(chapter);
  @include numberChapters($chapterTitleContent);
  @include countAppendices(appendix);
  @include numberAppendices($appendixTitleContent);
  @include countSections(section);
  @include numberSections($sectionTitleContent);
  @include countExamples(example);
  @include numberExamples($exampleTitleContent, $exampleSolutionTitleContent);

  @include refSectionHeaderStringAs(sectionHeaderString);
  @include refBookMetadataNodeAs(bookMetaNode);
  @include createChapterComposites($chapterCompositePages, sectionHeaderString, bookMetaNode);

  @include countTerms(term);
  @include refPageIDStringAs(pageID);
  @include prepIndexTerms(term, pageID);
}
:pass(1) {
  //Only use when all eoc composite pages already have metadata
  @include retitleCompositeMetadata($chapterCompositePages);

  @include refSectionHeaderStringAs(sectionHeaderString);
  @include refChapterHeaderStringAs(chapterHeaderString);
  @include createBookComposites($bookCompositePages, sectionTitleString, chapterTitleString, bookMetaNode);

  @include countEOCExercises(exercise);
  @include numberEOCExercises($exerciseTitleContent, $exerciseTitleContent);
}
:pass(2) {
  @include countEOCExercises(exercise);
  @include linkToProblemsFromSolutionsEOC("number", "number", exercise);
}
:pass(3) {
  //Only move solutions after exercises/solutions are numbered
  @include prepEOCSolutions($chapterCompositePages, bSolutions);
  @include putSolutionsEOC(bSolutions, "solutions");
}
:pass(4) {
  @include countTables(table);
  @include numberTables();
}
:pass(100) {
  @include clearTrash();
}
@mixin clearTrash() {
  body {
    &::after {
      content: clear(trash);
    }
  }
}

@mixin sendSectionTitleNodeAs($name) {
  div[data-type="page"] > [data-type="document-title"] {
    @include sendNodeAs($name);
  }
}
@mixin sendNodeAs($name) {
  node-set: $name;
}

@mixin createChapterComposites($compositePages, $sectionTitleNode) {
  @each $sourceSelector, $section-separated in $compositePages {
    @include createChapterComposite($sourceSelector, $section-separated, $sectionTitleNode);
  }
}

@mixin createChapterComposite($sourceSelector, $section-separated, $sectionTitleNode) {
  div[data-type="chapter"] {
    //Slight hack: these selectors should get everything including glossary definitions
    //Hope that structure doesn't change and that using
    //div[data-type] wont be needed to fetch anything but definitions
    //May need to eventually separate the creation of glossary type pages
    section.#{$sourceSelector},
    div[data-type="#{$sourceSelector}"] dl {
      @if ($section-separated) {
        content: nodes($sectionTitleNode) content();
      }
      > h1[data-type="title"] {
        move-to: trash;
      }
      move-to: #{$sourceSelector};
    }
    &::after {
      container: div;
      content: pending(#{$sourceSelector});
      class: "eoc #{$sourceSelector}-container";
      data-type: composite-page;
      //This should only really do anything for the glossary...
      //so it feels kinda dumb to have this here for everything
      sort-by: #{"dl > dt"}, nocase;
    }
  }
}

//[Document Usage]
@mixin title($content, $bucket: null, $container: null, $containerClass: null, $containerDestination: null) {
  @if (length(nth($content, 1)) > 1) {
    //If $content is parsed as a list of lists
    @each $itemContent, $itemClass in $content {
      &::before {
        container: span;
        content: $itemContent;
        class: "title-#{$itemClass}";
        @if ($bucket != null) {
          move-to: $bucket;
        }
      }
    }
  } @else {
    //If $content is parsed as a single list with two text elements
    $itemContent: nth($content, 1);
    $itemClass: nth($content, 2);
    &::before {
      container: span;
      content: $itemContent;
      class: "title-#{$itemClass}";
      @if ($bucket != null) {
        move-to: $bucket;
      }
    }
  }
  @if ($container != null and $containerClass != null) {
    &::before {
      container: $container;
      class: $containerClass;
      content: pending($bucket);
      @if ($containerDestination != null) {
        move-to: $containerDestination;
      }
    }
  }
}

//[Document Usage]
@mixin count($name, $selector, $resetSelector) {
  //Improvement: Resetting isn't dry, recreates selector if more than one counter resets on one element
  #{$resetSelector} {
    counter-reset: $name;
  }
  #{$selector} {
    counter-increment: $name;
  }
}

@mixin countChapters($name) {
  @include count($name, "div[data-type="chapter"]", "body");
}
@mixin countAppendices($name) {
  @include count($name, "div.appendix", "body");
}
@mixin countSections($name) {
  @include count($name, "div[data-type="chapter"] > div[data-type="page"]:not(.introduction)", "div[data-type="chapter"]");
}
@mixin countExercises($name) {
  @include count($name, "[data-type="exercise"]", "div[data-type="chapter"]")
}
@mixin countExamples($name) {
  @include count($name, "div[data-type="chapter"] .example", "div[data-type="chapter"]");
}

@mixin titlePreface() {
  //This only changes a container
  //will this be needed once the headers in raw are changed?
  div.preface {
    > [data-type="document-title"] {
      container: h1;
      content: content();
    }
  }
}

@mixin numberChapters($chapterTitleContent) {
  div[data-type="chapter"] {
    @include title($chapterTitleContent, bChapterLabel);
    //use the title mixin for this?
    > [data-type="document-title"] {
      container: h1;
      content: pending(bChapterLabel) content();
    }
  }
}

@mixin numberAppendices($appendixTitleContent) {
  div.appendix {
    @include title($appendixTitleContent, bAppendixLabel);
    //use the title mixin for this?
    > [data-type="document-title"] {
      container: h1;
      content: pending(bAppendixLabel) content();
    }
  }
}

@mixin numberSections($sectionTitleContent) {
  div[data-type="chapter"] > div[data-type="page"] {
    &:not(.introduction) {
      @include title($sectionTitleContent, bSectionLabel);
      //use the title mixin for this?
      > [data-type="document-title"] {
        container: h2;
        content: pending(bSectionLabel) content();
      }
    }
    &.introduction {
      > [data-type="document-title"] {
        container: h2;
      }
    }
  }
}

//EOC composite pages must be created before this runs
//TODO: Add .eoc to first selector
@mixin numberEOCExercises($exerciseTitleContent, $solutionTitleContent) {
  [data-type="exercise"] {
    [data-type="problem"] {
      @include title($exerciseTitleContent);
    }
    [data-type="solution"] {
      @include title($exerciseTitleContent);
    }
  }
}

@mixin numberExamples($exampleTitleContent, $solutionTitleContent) {
  .example {
    @include title($exampleTitleContent, bExampleLabel);
    > [data-type="title"] {
      $exampleTitle: (
        (content(), "text")
      );
      @include title($exampleTitle, bExampleLabel);
      move-to: trash;
    }
    &::after {
      container: h3;
      content: pending(bExampleLabel);
      class: "example-title";
      move-to: bExampleHeader;
    }
    &:deferred {
      content: pending(bExampleHeader) content();
    }
    [data-type="solution"] {
      @include title($solutionTitleContent, bSolutionLabel, h4, "example-solution-title");
    }
  }
}

@mixin linkToFrom($toSelector, $fromSelector, $toName, $toCounter: null) {
  #{$toSelector} {
    @if ($toCounter !=null) {
      $toID: $toName counter($toCounter);
      attr-id: $toID;
      string-set: #{$toName}-ID $toID;
    } @else {
      string-set: #{$toName}-ID attr(id);
    }

  }
  #{$fromSelector} {
    &::outside {
      container: a;
      attr-href: "#" string(#{$toName}-ID);
    }
  }
}

//This will wrap the whole solution, modify the selector when the new pass system is implemented
//to only wrap the .number inside solution on a later pass
//TODO: Add .eoc to selectors
@mixin linkEOCSolutionsToProblems() {
  @include linkToFrom("[data-type="problem"]", "[data-type="solution"]", problem);
}


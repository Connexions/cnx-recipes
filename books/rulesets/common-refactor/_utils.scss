//[Document Usage]
@mixin count($name, $selector, $resetSelector) {
  //Improvement: Resetting isn't dry, recreates selector if more than one counter resets on one element
  #{$resetSelector} {
    counter-reset: $name;
  }
  #{$selector} {
    counter-increment: $name;
  }
}

//[Document Usage]
@mixin title($content, $bucket: null, $container: null, $containerType: null) {
  //TODO: Restrict what things titlePart can be. Currently any key will work.
  @each $titlePart in map-keys($content) {
    &::before {
      container: span;
      content: map-get($content, $titlePart);
      class: $titlePart;
      @if ($container != null and $containerType != null) {
        move-to: #{$bucket}-TITLECONTAINER
      } @else if ($bucket != null) {
        move-to: $bucket;
      }
    }
  }
  @if ($container != null and $containerType != null) {
    &::before {
      container: $container;
      data-type: $containerType;
      content: pending(#{$bucket}-TITLECONTAINER);
      @if ($bucket != null) {
        move-to: $bucket;
      }
    }
  }
}

//Relies on hitting From Selector then To Selector without anything in between repeatedly
//:'( this is less robust and useful than originally envisioned, still works great for solutions though
@mixin linkToFrom($toSelector, $fromSelector, $toName, $toCounter: null) {
  #{$toSelector} {
    @if ($toCounter != null) {
      $toID: "#{$toName}-"counter($toCounter);
      attr-id: $toID;
      string-set: #{$toName}-ID $toID;
    } @else {
      string-set: #{$toName}-ID attr(id);
    }

  }
  #{$fromSelector} {
    &::outside {
      container: a;
      attr-href: "#" string(#{$toName}-ID);
    }
  }
}

@mixin refNodeAs($name) {
  node-set: $name;
}

@mixin refStringAs($name, $string) {
  string-set: $name $string;
}

@mixin clearTrash() {
  body::after {
    content: clear(trash);
  }
}

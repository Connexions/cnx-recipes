<<<<<<< HEAD
/// Base counting mixin - creates a counter with the given name, increment location, and reset location
/// @arg {Text} $name - The unquoted name of the counter that will be created
/// @arg {String} $selector - A string of the selector at which the counter will increment
/// @arg {String} $resetSelector - A string of the selector at which the counter will reset
@mixin utils_count($name, $selector, $resetSelector) {
=======
//[Document Usage]
@mixin count($name, $selector, $resetSelector) {
>>>>>>> Separate mixins into their respective files, do some work on solutions
  //Improvement: Resetting isn't dry, recreates selector if more than one counter resets on one element
  #{$resetSelector} {
    counter-reset: $name;
  }
  #{$selector} {
    counter-increment: $name;
  }
}

<<<<<<< HEAD
/// Base titling and numbering mixin - Creates <span> elements before an element defined by the content passed. These <span> elements can be automatically wrapped and/or sent to a specified bucket
/// @arg {Map} $content - A content map containing key and value pairs. Each key, value pair creates a <span> of class="key" with a text node of "value"
/// @arg {Text} $bucket [null] - The unquoted name of the bucket to send the resulting object(s) to. If null, resulting object(s) will remain in place, before the element the mixin was called within
/// @arg {Text} $container [null] - The unquoted type of container element to send the titling spans to (e.g. h1, h2, div). If null, resulting spans will not be wrapped
/// @arg {String} $containerType [null] - The data-type to give to the created container element. If null, resulting spans will not be wrapped
@mixin utils_title($content, $bucket: null, $container: null, $containerType: null) {
  //TODO: Restrict what things titlePart can be. Currently any key will work.
  @each $titlePart in map-keys($content) {
    &::before {
      container: span;
      content: map-get($content, $titlePart);
      class: $titlePart;
      @if ($container != null and $containerType != null) {
        move-to: #{$bucket}-TITLECONTAINER
      } @else if ($bucket != null) {
=======
//[Document Usage]
@mixin title($content, $bucket: null, $container: null, $containerType: null) {
    @each $key in map-keys($content) {
      &::before {
        container: span;
        content: map-get($content, $key);
        class: $key;
        @if ($bucket != null) {
          @if ($container != null and $containerType != null) {
            move-to: #{$bucket}-TITLECONTAINER
          } @else {
            move-to: $bucket;
          }
        }
      }
<<<<<<< HEAD
    }
  } @else {
    //If $content is parsed as a single list with two text elements
    $itemContent: nth($content, 1);
    $itemClass: nth($content, 2);
    &::before {
      container: span;
      content: $itemContent;
      class: $itemClass;
      @if ($bucket != null) {
<<<<<<< HEAD
>>>>>>> Separate mixins into their respective files, do some work on solutions
        move-to: $bucket;
      }
    }
  }
<<<<<<< HEAD
  @if ($container != null and $containerType != null) {
    &::before {
      container: $container;
      data-type: $containerType;
      content: pending(#{$bucket}-TITLECONTAINER);
      @if ($bucket != null) {
        move-to: $bucket;
=======
  @if ($container != null and $containerClass != null) {
    &::before {
      container: $container;
      class: $containerClass;
      content: pending($bucket);
      @if ($containerDestination != null) {
        move-to: $containerDestination;
>>>>>>> Separate mixins into their respective files, do some work on solutions
      }
=======
        @if ($container != null and $containerType != null) {
          move-to: #{$bucket}-TITLECONTAINER
        } @else {
          move-to: $bucket;
        }
      }
    }
=======
>>>>>>> map conversion
  }
  @if ($container != null and $containerType != null) {
    &::before {
      container: $container;
      data-type: $containerType;
      content: pending(#{$bucket}-TITLECONTAINER);
      move-to: $bucket;
>>>>>>> Rewrite composition mixins to handle pages with mapped properties
    }
  }
}

<<<<<<< HEAD
//Relies on hitting To Selector then From Selector without anything in between repeatedly
//:'( this is less robust and useful than originally envisioned, still works great for solutions -> exercises though
//Additionally a counter may not need to be passed, and a new method could rely on an internal counter
//Stronger linking idea:
//pass1: create objects
//pass2: give similar ids to objects to be linked (e.g. #problem-3, #solution-3)
//pass3: link the objects in any order because you know both ids

/// Links pairs of elements that occur in the tree in order: To, From, To, From, ... with no exceptions
/// @arg {String} $toSelector - The selector of the element in the pair that will be linked to
/// @arg {String} $fromSelector - The selector of the element in the pair that will be the link
/// @arg {Text} $toCounter [null] - The counter object used to automatically ID the element to be linked to if it doesn't already have an id. If null, the link href will be to an already existing id of the linked-to element
@mixin utils_linkToFromForward($toSelector, $fromSelector, $toName, $toCounter: null) {
=======
@mixin linkToFrom($toSelector, $fromSelector, $toName, $toCounter: null) {
>>>>>>> Separate mixins into their respective files, do some work on solutions
  #{$toSelector} {
    @if ($toCounter != null) {
      $toID: "#{$toName}-"counter($toCounter);
      attr-id: $toID;
      string-set: #{$toName}-ID $toID;
    } @else {
      string-set: #{$toName}-ID attr(id);
    }
<<<<<<< HEAD
=======

>>>>>>> Separate mixins into their respective files, do some work on solutions
  }
  #{$fromSelector} {
    &::outside {
      container: a;
      attr-href: "#" string(#{$toName}-ID);
    }
  }
}

<<<<<<< HEAD
/// Simply base mixin to reference a node
/// @arg {Text} $name - The unquoted name of the node that will be referenced
@mixin utils_refNodeAs($name) {
  node-set: $name;
}

/// Simply base mixin to reference a string
/// @arg {Text} $name - The unquoted name of the string that will be referenced
/// @arg {String} $string - The referenced string. Often, this will be to an element's content() or an attr()
@mixin utils_refStringAs($name, $string) {
  string-set: $name $string;
}

/// A simple call to clear the trash at the end of a pass/step
@mixin utils_clearTrash() {
  body:deferred::after {
=======
@mixin refNodeAs($name) {
  node-set: $name;
}

@mixin refStringAs($name) {
  string-set: $name;
}

@mixin clearTrash() {
  body::after {
>>>>>>> Separate mixins into their respective files, do some work on solutions
    content: clear(trash);
  }
}

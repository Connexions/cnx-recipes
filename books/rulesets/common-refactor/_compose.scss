@import "./utils";

@mixin createChapterComposites($compositePages, $sectionTitleNode, $bookMetadataNode) {
  @each $page in $compositePages {
    @include createChapterComposite($page, $sectionTitleNode, $bookMetadataNode);
  }
}

@mixin createChapterComposite($page, $sectionTitleNode, $bookMetadataNode) {
  div[data-type="chapter"] {
    $name: map-get($page, name);
    $source: map-get($page, source);
    $sortBy: map-get($page, sortBy);
    $compoundComposite: map-get($page, compoundComposite);
    @if (not $compoundComposite) {
      $sectionSeparated: map-get($page, sectionSeparated);
      $isGlossary: map-get($page, isGlossary);
      $sourceSelector: if($isGlossary, 'div[data-type="#{$source}"] dl', 'section.#{$source}');
      #{$sourceSelector} {
        @if ($sectionSeparated) {
          content: nodes($sectionTitleNode) content();
        }
        > h1[data-type="title"] {
          move-to: trash;
        }
        move-to: #{$source}-TOCOMPOSITE;
      }
    }

    //BAD: there should not be titling content creation outside the book level. This should get moved
    $pageTitleContent: (
      text: $name
    );
    @include title($pageTitleContent, #{$source}-composite-title, h2, "document-title");
    &::after {
      container: div;
      @if (not $compoundComposite) {
        content: nodes($bookMetadataNode) pending(#{$source}-composite-title) pending(#{$source}-TOCOMPOSITE);
      } @else {
        content: nodes($bookMetadataNode) pending(#{$source}-composite-title);
      }
      class: "eoc #{$source}-container";
      data-type: "composite-page";
      @if ($sortBy != null) {
        sort-by: #{$sortBy}, nocase;
      }
    }
  }
}

@mixin retitleCompositeMetadata($compositePages) {
  @each $page in $compositePages {
    $name: map-get($page, name);
    $source: map-get($page, source);
    [data-type="composite-page"].#{$source}-container > [data-type="metadata"] > [data-type="document-title"] {
      content: $name;
    }
  }
}

@mixin putSolutions($bucket, $selector) {
  #{$selector} {
    content: content() pending($bucket);
  }
}

@mixin putSolutionsEOC($bucket, $selector) {
  @include putSolutions($bucket, ".eoc.#{$selector}-container")
}

@mixin prepEOCSolutions($compositePages, $solutionBucket, $sectionHeaderNode: null, $chapterHeaderNode: null) {
  @each $page in $compositePages {
    $hasSolutions: map-get($page, hasSolutions);
    $source: map-get($page, source);
    @if ($hasSolutions) {
      [data-type="chapter"] {
        .eoc.#{$source}-container {
          [data-type="solution"] {
            @if ($sectionHeaderNode == null and $chapterHeaderNode == null) {
              move-to: $solutionBucket;
            } @else if ($sectionHeaderNode != null) {
              move-to: #{$solutionBucket}-GETSECTION;
            } @else {
              move-to: #{$solutionBucket}-GETCHAPTER;
            }
          }
          @if ($sectionHeaderNode != null) {
            &::after {
              content: nodes($sectionHeaderNode) pending(#{$solutionBucket}-GETSECTION);
              class: "section-area";
              @if ($chapterHeaderNode != null) {
                move-to: #{$solutionBucket}-GETCHAPTER;
              } @else {
                move-to: $solutionBucket;
              }
            }
          }
        }
        @if ($chapterHeaderNode != null) {
          &::after {
            content: nodes($chapterHeaderNode) pending(#{$solutionBucket}-GETCHAPTER);
            class: "chapter-area";
            move-to: $solutionBucket;
          }
        }
      }
    }
  }
}
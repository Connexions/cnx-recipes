const {stuff} = require('./chemistry-extracted')


console.log(`
//
// This file is AUTOGENERATED.
//

enum LENGTH {
    PERCENT = '%',
    REM = 'rem',
    PX = 'px',
}

enum SLICE_ENUM {
    SLICE,
    AUTO,
    DEFAULT
}


class Component {
    private readonly properties: any
    constructor(defaults: any, config: any) {
        this.properties = {...defaults, ...config}
    }
}

class Shape {
    private readonly groups: any
    private readonly components: Component[]
    constructor(defaults: any, config: any, components: Component[]) {
        this.groups = {...defaults, ...config}
        this.components = [...components]
    }
}

`)



function getOrAdd(map, key, defaultValue) {
    if (!map) {
        throw new Error('Woah buddy.. there is no map to look into')
    }
    if (!map.has(key)) {
        map.set(key, defaultValue)
    }
    return map.get(key)
}


function toString(value) {
    if (value && value._ref) {
        return escapeName(value._ref)
    }
    switch (value) {
        case 'rem': return 'LENGTH.REM'
        case 'px': return 'LENGTH.PX'
        case '%': return 'LENGTH.PERCENT'
    }

    return JSON.stringify(value)
}

function getTypeOf(value) {
    // The SASS->JSON conversion sometimes puts an empty entry at the beginning of arrays
    if (Array.isArray(value) && value[0] === undefined) {
        value.shift()
    }
    if (Array.isArray(value)) {
        if (value.length === 2 && value[0] === 'ENUM__ValueSet:::OPTIONAL') {
            return getTypeOf(value[1])
        } else if (value.length === 1) {
            return getTypeOf(value[0])
        } else if (value.length === 2) {
            return `[${value.map(v => getTypeOf(v)).join(', ')}]`
        } else {
            console.warn(`NOT sure how to build a type for this`, value)
            return '[number, string]'
        }
    } else if (typeof value === 'number') {
        return 'number'
    } else {
        switch (value) {
            case 'rem':
            case 'px':
            case '%': return 'LENGTH'
            
            case 'solid': 
            case 'slice':
                return 'SLICE_ENUM'
            case 'ENUM__ValueSet:::OPTIONAL':
            case 'ENUM__ValueSet:::REQUIRED':
                return `any /* ${value} */`
            default:
                console.warn(`Could not determine type of "${value}"`)
                return `any /* ${value} */`
        }
    }
}

function isValue(value) {
    // The SASS->JSON conversion sometimes puts an empty entry at the beginning of arrays
    if (Array.isArray(value) && value[0] === undefined) {
        value.shift()
    }
    if (Array.isArray(value)) {
        if (value.length === 2 && value[0] === 'ENUM__ValueSet:::OPTIONAL') {
            return isValue(value[1])
        } else if (value.length === 1) {
            return isValue(value[0])
        } else if (value.length === 2) {
            return isValue(value[0]) && isValue(value[1])
        } else {
            return true
        }
    } else if (typeof value === 'number') {
        return true
    } else {
        switch (value) {
            case 'rem':
            case 'px':
            case '%': return true
            
            case 'solid': 
            case 'slice':
                return true
            case 'ENUM__ValueSet:::OPTIONAL':
            case 'ENUM__ValueSet:::REQUIRED':
                return false
            default:
                console.warn(`Could not determine whether this is a value ${JSON.stringify(value)}`)
                return true
        }
    }

}


function escapeName(name) {
    return name
        .replace(/:::/g, '___')
        .replace(/-/g, '_')
}

const shapeComponents = new Map() // String => String[]

stuff.shapes.forEach(([name, config]) => {
    if (config._parent !== 'ENUM__Object:::NONE') {
        throw new Error(`BUG: Oooh, a shape with a parent! We don't handle that yet`)
    }

    const shapeName = escapeName(name)

    const groups = !config._groups ? [] : Object.entries(config._groups).map(([key, value]) => {
        const isRequired = value === 'ENUM__ValueSet:::REQUIRED'
        return `'${key}'${isRequired ? '' : '?'}: ${getTypeOf(value)}`
    })

    const groupDefaults = !config._groups ? [] : Object.entries(config._groups).map(([key, value]) => {
        if (isValue(value)) {
            return `'${key}': ${toString(value)}` 
        } else {
            return null
        }
    }).filter(e => e != null) // remove any non-value entries

    const componentNamesUnique = new Set()
    const componentDefinitions = []
    const componentUses = []
    const componentArgNames = []

    const componentOrder = getOrAdd(shapeComponents, shapeName, [])

    config._components.forEach(({_name, _subselector, _properties}) => {
        const argName = `c${componentUses.length}`
        const componentName = `${shapeName}_${escapeName(_name)}`

        if (!componentNamesUnique.has(componentName)) {
            componentOrder.push(componentName)
            const properties = Object.entries(_properties).map(([key, value]) => {
                const isRequired = value === 'ENUM__ValueSet:::REQUIRED'
                return `'${key}'${isRequired ? '' : '?'}: ${getTypeOf(value)}`
            })

            const propDefaults = !_properties ? [] : Object.entries(_properties).map(([key, value]) => {
                if (isValue(value)) {
                    return `'${key}': ${toString(value)}` 
                } else {
                    return null
                }
            }).filter(e => e != null) // remove any non-value entries
        
        
            componentArgNames.push(argName)
            componentUses.push(`${argName}: ${componentName}`)
            componentDefinitions.push(`
            class ${componentName} extends Component {
                constructor(config: {
                    ${properties.join(', ')}
                }) {
                    const defaults = {${propDefaults.join(', ')}}
                    super(defaults, config)
                }
            }
            `)
            componentNamesUnique.add(componentName)
        }

    })

    console.log(`
    // START: ${shapeName}
    ${componentDefinitions.join('\n')}
    class ${shapeName} extends Shape {
        constructor(config: {
            ${groups.join(', ')}
        }, ${componentUses.join(', ')}) {
            const defaults = {${groupDefaults.join(', ')}}
            super(defaults, config, [${componentArgNames.join(', ')}])
        }
    }
    // END: ${shapeName}
    `)
})



// Split each thing key up so we can look it up
const instances = new Map()
const usedRefs = new Set() // "colorMap:::background"

stuff.things.forEach(([key, value]) => {
    const keys = key.split(':::')
    const instanceName = keys[0]
    const groupOrComponent = keys[1]

    const entry = getOrAdd(instances, instanceName, {selectors: null, groups: new Map(), components: new Map()})
    
    if (value && value._ref) {
        usedRefs.add(value._ref)
    }

    // Either we are setting the _selectors, or a group field, or a Component:
    if (groupOrComponent === '_selectors') {
        entry.selectors = value
    } else if (keys.length > 2) {
        // Component
        const componentName = groupOrComponent
        const componentPropertyName = keys[2]
        const componentProperties = getOrAdd(entry.components, componentName, new Map())
        componentProperties.set(componentPropertyName, value)
    } else {
        // Groups
        const groupName = groupOrComponent
        entry.groups.set(groupName, value)
    }
})

stuff.things.forEach(([key, value]) => {
    if (usedRefs.has(key)) {
        console.log(`const ${escapeName(key)} = ${toString(value)}`)
    }
})

// console.warn(instances)


stuff.uses.forEach(([instanceName, className]) => {
    const shapeName = escapeName(className)
    const instanceConfig = instances.get(instanceName)
    const groups = [...instanceConfig.groups.entries()].map(([key, value]) => `/*group*/ '${key}': ${toString(value)}`)
    const cPhil = shapeComponents.get(shapeName)
    console.log(`/* componentlist...length=${cPhil.length} . entries: ${JSON.stringify(cPhil)} */`)
    const components = cPhil.map(componentName => {
        const lookup = componentName.replace(`${shapeName}_`, '') // Remove the prefix 
        let properties1 = instanceConfig.components.get(lookup)
        if (!properties1) {
            console.log(`// was looking for '${lookup}' but did not find it. assuming that all properties of this object have defaults`)
            properties1 = new Map()
        }
        const properties2 = [...properties1.entries()].map(([key, value]) => `/*prop*/ '${key}': ${toString(value)}`)
        return `new ${componentName}({${properties2.join(',')}})`
    })

    console.log(`
    const ${instanceName} = new ${shapeName}({${groups.join(', ')}}, ${components.join(', ')})`)
})